---
layout: task
title: Introduction
category: lab
lab: 1
task: 1
brief: Introduction to control system
---

## About

The control system of Velma robot is a complex, hierarchical structure.
It is based on the Embodied Agent specification method developed at
[Institute of Control & Computation Engineering at WARSAW UNIVERSITY OF TECHNOLOGY](https://www.robotyka.ia.pw.edu.pl/).

## Structure of the system

The control system consists of four abstraction levels. Each level contains at least one subsystem. On the implementation level, subsystems are separate processes in operating system. Such distributed structure has some advantages:
* subsystems can be easily replaced, if the replacements have the same communication buffers; in particular, hardware-operating subsystems can be replaced with simulation subsystem, thus both real-hardware and simulated systems share utmost parts,
* critical error in one subsystem does not affect other subsystems, so they can react adequately to keep proper operation of the system,
* lower subsystems in the hierarchy are simpler and thus more error proof, they can react immediately to errors in upper subsystems.

The structure of the simulated system is:

![]({{site.baseurl}}/public/img/system.dot.png)

The structure of the real-hardware system is similar:

![]({{site.baseurl}}/public/img/system_hw.dot.png)

The only difference between them is in the lowest level of abstraction.
Subsystems that communicate with hardware are exchangeable with one subsystem that simulates the whole robot.

## Behaviors
Each subsystem realizes one or multiple behaviors. The behavior switching is governed by a Finite State Machine (FSM), so that one behavior can be executed in one or multiple states.

### velma_core_ve_body
FSM of velma_core_ve_body subsystem:

![]({{site.baseurl}}/public/img/velma_core_ve_body_fsm.png)

The conditions are:

   * $$\sigma_{\texttt{safe},\texttt{safe_st}} =  \texttt{recvStatus}   \wedge  \neg \texttt{allHwOk}$$
   * $$\sigma_{\texttt{safe},\texttt{safe_st_ok}} =  \texttt{recvStatus}   \wedge   \texttt{allHwOk}$$ 
   * $$\sigma_{\texttt{safe},\texttt{idle}} = \neg   \texttt{recvStatus}$$
   * $$\sigma_{\texttt{safe_st},\texttt{safe}} =  \texttt{TRUE} $$
   * $$\sigma_{\texttt{safe_st_ok},\texttt{safe}} = ( \neg   \texttt{recvCommand} )  \vee  ( \neg \texttt{allCmdOk}) \vee  ( \neg   \texttt{cmdExitSafeState} )  \vee  ( \neg   \texttt{safeItPassed500} )$$
   * $$\sigma_{\texttt{safe_st_ok},\texttt{transp}} =  \texttt{recvCommand}   \wedge   \texttt{allCmdOk}  \wedge   \texttt{cmdExitSafeState}   \wedge   \texttt{safeItPassed500} $$
   * $$\sigma_{\texttt{transp},\texttt{safe_st}} =  \texttt{recvStatus}   \wedge  ( \neg \texttt{allHwOk})$$
   * $$\sigma_{\texttt{transp},\texttt{transp_st}} =  \texttt{recvStatus}   \wedge   \texttt{allHwOk} $$
   * $$\sigma_{\texttt{transp},\texttt{idle}} = ( \neg   \texttt{recvStatus} )$$
   * $$\sigma_{\texttt{transp_st},\texttt{transp}} =  \texttt{recvCommand}   \wedge   \texttt{allCmdOk}$$
   * $$\sigma_{\texttt{transp_st},\texttt{safe}} = ( \neg   \texttt{recvCommand} )  \vee  ( \neg   \texttt{allCmdOk})$$
   * $$\sigma_{\texttt{idle},\texttt{safe_st}} =  \texttt{recvStatus} $$

Where:

$$\texttt{allHwOk} = \texttt{rLwrOk}   \wedge   \texttt{lLwrOk}   \wedge   \texttt{rLwrInCmdState}  \\ \wedge   \texttt{lLwrInCmdState}   \wedge   \texttt{tMotorOk}   \wedge   \texttt{hpMotorOk}   \wedge   \texttt{htMotorOk}$$

and

$$\texttt{allCmdOk} = \texttt{rLwrCmdOk}   \wedge   \texttt{lLwrCmdOk}   \wedge   \texttt{tCmdOk}$$

### velma_core_cs

FSM of velma_core_cs subsystem:

![]({{site.baseurl}}/public/img/velma_core_cs_fsm.png)

The conditions are:

   * $$\sigma_{\texttt{idle},\texttt{safe}} =  \texttt{veBodyStatusValid}   \wedge  ( \neg   \texttt{veBodyInSafeState} ) $$
   * $$\sigma_{\texttt{idle},\texttt{safe}} =  \texttt{veBodyStatusValid}   \wedge  ( \neg   \texttt{veBodyInSafeState} ) $$
   * $$\sigma_{\texttt{safe},\texttt{idle}} =  \texttt{IN_ERROR} $$
   * $$\sigma_{\texttt{safe},\texttt{cart_imp}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvCartImpCmd} $$
   * $$\sigma_{\texttt{safe},\texttt{jnt_imp}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvJntImpCmd} $$
   * $$\sigma_{\texttt{safe},\texttt{safe_col}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvSafeColCmd} $$
   * $$\sigma_{\texttt{safe_col},\texttt{idle}} =  \texttt{IN_ERROR} $$
   * $$\sigma_{\texttt{safe_col},\texttt{cart_imp}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvCartImpCmd} $$
   * $$\sigma_{\texttt{safe_col},\texttt{jnt_imp}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvJntImpCmd} $$
   * $$\sigma_{\texttt{cart_imp},\texttt{idle}} =  \texttt{IN_ERROR} $$
   * $$\sigma_{\texttt{cart_imp},\texttt{safe}} = ( \neg   \texttt{IN_ERROR} )  \wedge  ( \neg   \texttt{recvOneCmd} )$$
   * $$\sigma_{\texttt{cart_imp},\texttt{jnt_imp}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvJntImpCmd} $$
   * $$\sigma_{\texttt{cart_imp},\texttt{safe_col}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvSafeColCmd}$$ 
   * $$\sigma_{\texttt{jnt_imp},\texttt{idle}} =  \texttt{IN_ERROR} $$
   * $$\sigma_{\texttt{jnt_imp},\texttt{safe}} = ( \neg   \texttt{IN_ERROR} )  \wedge  ( \neg   \texttt{recvOneCmd} )$$
   * $$\sigma_{\texttt{jnt_imp},\texttt{cart_imp}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvCartImpCmd} $$
   * $$\sigma_{\texttt{jnt_imp},\texttt{safe_col}} = ( \neg   \texttt{IN_ERROR} )  \wedge   \texttt{recvOneCmd}   \wedge   \texttt{recvSafeColCmd} $$





TODO: text

| TODO: table             | TODO           |
| TODO: table             | TODO           |
| TODO: table             | TODO           |

## TODO

   * **TODO** - list 1
   * **TODO** - list 2

[comment]: ![]({{site.baseurl}}/public/l1/pattern_explained.png)

## Do poczytania
TODO

[comment]:   * Rozdział 11: _Camera models and calibration_ (str. 270-404) z książki _Learning OpenCV. Computer Vision with the OpenCV Library_, Gary Bradski and Adrian Kaehler, O'Reilly Media, 2008
[comment]:   * OpenCV reference manual: [Camera Calibration and 3D Reconstruction](http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html)
[comment]:      * [findChessboardCorners](http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findchessboardcorners)
[comment]:      * [findCirclesGrid](http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findcirclesgrid)
[comment]:      * [calibrateCamera](http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera)
[comment]:      * [undistort](http://docs.opencv.org/2.4/modules/imgproc/doc/geometric_transformations.html#undistort)

